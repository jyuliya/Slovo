# Ренева Юлия Денисовна, группа БПМИ 154

## Проект "Слово за слово"

### I. Описание задачи

Задача проекта - написать приложение, предлагающее пользователю словарь сленговых слов с дефинициями и ближайшими синонимами. Стартовой страницей будет топ самых часто встречающихся в социальных сетях сленговых слов. Как дополнительные фукнции в приложении можно реализовать авторизацию пользователей, лайки, рекламу.

### II. Технологические решения

Для получения базы слов написан парсер с использованием python-библиотеки Beautiful soap, так как эта библиотека наиболее проста для понимания и использования. Полученный с сайта текст записан в тектовый файл. Для выбора версии python составлена таблица сравнения:

|различия|python 2|python 3|
|----|-----|------|
|Считывание|	raw_input()<br> input()	|input() <br>eval(input())|
Print - функция|print|print(), можно настроить разделитель между элементами (sep=""), не поддерживает функцию программный пробел|
Байтовые типы|Класс bytearray|Новый тип - байтовая константа и новый класс - bytes|
Строки|Тип unicode<br>Встроенный оператор форматирования строк - %|Отдельный строковый тип str<br>Строковые объекты теперь имеют метод format(), принимающий позиционные и именованные аргументы, которые передаются в поля подстановки<br>Модули StringIO и cStringIO удалены<br>Кодировка исходного кода по умолчанию теперь UTF-8|
Методы словарей| Отображения и итераторы вместо списков<br>dict.keys(), dict.items() и dict.values() возвращают списки<br>методы map(), zip() и filter() возвращают списки|Методы словарей dict.keys(), dict.items() и dict.values() возвращают "отображения"<br>Методы dict.iterkeys(), dict.iteritems() и dict.itervalues() более не поддерживаются<br>map() и filter() возвращают итераторы<br>zip() возвращает итератор.|
Оператор in|range() теперь ведёт себя как xrange(), но работает со значениями любого размера| xrange() больше не существует|
Операторы сравнения|Операторы сравнения (<, <=, >=, >) возвращают False, когда операнды не упорядочиваемы<br>cmp()|Операторы сравнения (<, <=, >=, >) поднимают исключение TypeError, когда операнды не упорядочиваемы<br>Метод cmp() не поддерживается. Вместо него lt() для сортировки, eq(), hash() для сравнения|
Целые числа|	|long переименован в int<br>Выражение вида 1/2 возвращает float<br>Константа sys.maxint удалена|
Изменения синтаксиса|Встроенные функции	super() используется только с аргументами<br>apply(f, args)<br>callable(f)<br>execfile(fn)<br>callable(f)<br>dict.has_key()|super() можно использовать без аргументов<br>f(*args)<br>hasattr(f, "call")<br>exec(open(fn).read())<br>"True" и "False" и "None" - зарезервированные слова<br>Удалено <>|


Из таблицы видно, что в большинстве функционал python 3 изменился к лучшему, поэтому была выбрана именно эта версия.

Написать приложение для IOS можно на языке Swift или Objective-c. Для выбора так же составим таблицу:


|Swift|Objective-c|   |
|----|------|------|
|Плюсы|1. Для написания приложения требуется меньше кода, что делает сам код более понятным и читабельным.<br>2. Больше возможностей по сравнению с Objective-C, в частности возможность управлять памятью<br>3. Полноценное взаимодействие с кодом, написанным на Objective-C<br>4. Повышенная безопасность(например, в саму компиляцию можно встроить опциональную переменную nil для обеспечения обратной связи)<br>5. Мгновенная визуализация кода, что крайне полезно для начинающих разработчиков. |1. Динамическая типизация, в некоторых случаях это действительно может стать ключевым преимуществом. Например, упрощает создание несложных программ<br>2. Документация и сообщества: более 20 лет успешного применения языка поспособствовали появлению большого количества качественных ресурсов и книг. Сегодня любой, кто желает изучить Objective-C, без труда найдёт ответ на интересующий вопрос на просторах интернета<br>3. Простота работы с компилятором. Минусы| 1. Компилятор выдаёт излишние и сбивающие с толку ошибки.<br>2. Каждое небольшое изменение в коде требует пересборки проекта.<br>3. Отсутствие кросплатформеного компилятора, Swift пока можно использовать только для разработок под iOS и Mac. | 1. Низкая читаемость кода, что затрудняет изучение языка новичками<br>2. Динамическая типизация предполагает возможность появления ошибок даже во время компиляции.<br>3. Ограниченная функциональность.|

Из таблицы видно, что язык Swift намного легче для новичка, имеет множество преимуществ в функционале разработки. Единственным недостатком могло оказаться малое количество справочной литературы, но этот минус перестал существовать как таковой после того, как были найдены сайты с хорошей документацией. Поэтому, для написания приложения будет использоваться Swift.

Дизайн самого приложения будет появляться скорее по мере разработки, но пока что это представляетмя мне как стартовая страница с самым популярным словом (по типу "слово дня"), строка для поиска слова в верхней части экрана и кнопка в нижней части экрана "алфавитный указатель".

Чтобы получить самые часто используемые слова, будет использован Vk API, так как в России эта социальная сеть более популярна, чем Twitter.

### III. План работы

* Парсер и файл со всеми словами, их определениями и синонимами (10 декабря)
* Начало разработки архитектуры приложения для IOS, начало работы со Swift (10 января)
* Готовое приложение - словарь (11 марта)
* Понять работу Vk/Twitter API и добавить топ слов на стартовую страницу приложения (1 апреля)
* Word2vec Google технология - разбор и преобразование базы данных (10 мая)
* Доработка приложения до готового продукта (1 июня)

### IV. Архитектура программного продукта в целом и описание функциональности

В целом, вид приложения будет именно таким, как и предполагалось при планировании проекта - на стартовой странице поиск, топ слов, алфавитный указатель. При нажатии на поиск выскакивает клавиатура в нижней части экрана, по мере ввода букв в поисковую строку будут показываться наиболее подходящие слова в выпадающем меню. 

Выбранное для поиска слово будет отображаться на новом экране, внизу так же будет алфавитный указатель, выход на страницу поиска по кнопке в левом верхнем углу экрана.

Все слова хранятся в файле типа json, в виде словаря. Поиск слова осуществляется по ключу, по полю "definiton" выводится определение слова или выражения.


